<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Reaction Timer | Portfolio Project</title>

  <!-- Polished but subtle: tiny inline SVG favicon (no external request, no clutter) -->
  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop stop-color="%233B82F6"/><stop offset="1" stop-color="%2310B981"/></linearGradient></defs><rect width="64" height="64" rx="14" fill="%230F172A"/><path d="M18 42 L32 14 L46 42 Z" fill="url(%23g)"/><circle cx="32" cy="46" r="4" fill="%2394A3B8"/></svg>' />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@600;700&display=swap');

    :root{
      --bg:#0F172A;
      --surface:#1E293B;
      --surface-2:#0B1224;
      --border:#334155;
      --text:#F1F5F9;
      --muted:#94A3B8;
      --primary:#3B82F6;
      --ready:#10B981;
      --wait:#F59E0B;
      --error:#EF4444;
    }

    *{ margin:0; padding:0; box-sizing:border-box; }

    body{
      font-family:'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      flex-direction:column;
      overflow-x:hidden;
    }

    header{
      padding:2rem 1.5rem 1.25rem;
      text-align:center;
      background: linear-gradient(180deg, var(--surface) 0%, rgba(30,41,59,0) 100%);
    }

    h1{
      font-family:'Poppins', sans-serif;
      font-size:2.25rem;
      font-weight:700;
      margin-bottom:0.35rem;
      background: linear-gradient(135deg, var(--primary) 0%, var(--ready) 100%);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }

    .subtitle{
      color:var(--muted);
      font-size:0.98rem;
      font-weight:500;
    }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:1.75rem 1.25rem 2.25rem;
      gap:1.5rem;
    }

    .game-container{
      width:100%;
      max-width:860px;
      display:flex;
      flex-direction:column;
      gap:1rem;
      align-items:center;
    }

    /* Focused hierarchy: big game area, minimal controls */
    .canvas-wrapper{
      position:relative;
      width:100%;
      max-width:640px;
      aspect-ratio:1;
      background:var(--surface);
      border-radius:1.5rem;
      overflow:hidden;
      border:2px solid var(--border);
      box-shadow: 0 22px 60px rgba(0,0,0,0.35);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      outline:none;
      transition: border-color 220ms ease, transform 220ms ease;
    }

    .canvas-wrapper:hover{ border-color:#475569; }
    .canvas-wrapper:active{ transform: translateY(1px); }

    .canvas-wrapper:focus-visible{
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(59,130,246,0.25), 0 22px 60px rgba(0,0,0,0.35);
    }

    #gameCanvas{ display:block; width:100%; height:100%; }

    .hud{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:10;
    }

    /* Top-right message: minimal + legible */
    .status{
      position:absolute;
      top:1rem;
      right:1rem;
      max-width: calc(100% - 2rem);
      padding:0.85rem 1rem;
      border-radius:0.9rem;
      border:1px solid transparent;
      background: rgba(11,18,36,0.78);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 28px rgba(0,0,0,0.28);
      opacity:0;
      transform: translateY(-4px);
      transition: opacity 180ms ease, transform 180ms ease, border-color 180ms ease;
      font-family:'Poppins', sans-serif;
      line-height:1.15;
    }

    .status.visible{ opacity:1; transform: translateY(0); }

    .status .big{
      font-size:2.4rem;
      font-weight:700;
      letter-spacing:-0.02em;
    }

    .status .sub{
      margin-top:0.35rem;
      font-family:'Inter', sans-serif;
      color:var(--muted);
      font-size:0.95rem;
      font-weight:600;
    }

    .status.idle{ border-color: rgba(148,163,184,0.18); }
    .status.wait{ border-color: rgba(245,158,11,0.5); }
    .status.go{ border-color: rgba(16,185,129,0.55); }
    .status.result{ border-color: rgba(59,130,246,0.55); }
    .status.err{ border-color: rgba(239,68,68,0.55); }

    .status.idle .big{ color: var(--muted); font-size:1.15rem; font-weight:700; }
    .status.wait .big{ color: var(--wait); }
    .status.go .big{ color: var(--ready); }
    .status.result .big{ color: var(--primary); }
    .status.err .big{ color: var(--error); font-size:1.15rem; }

    /* Instructions inside game space, shown ONCE, disappear naturally on first start */
    .instructions{
      position:absolute;
      inset:0;
      z-index:20;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(15,23,42,0.94);
      backdrop-filter: blur(12px);
      transition: opacity 240ms ease;
    }

    .instructions.hidden{
      opacity:0;
      pointer-events:none;
    }

    .instructions-card{
      width:min(520px, calc(100% - 2.25rem));
      padding:1.4rem 1.35rem;
      border-radius:1.2rem;
      border:1px solid rgba(148,163,184,0.18);
      background: rgba(11,18,36,0.72);
      box-shadow: 0 16px 50px rgba(0,0,0,0.35);
    }

    .instructions-card h2{
      font-family:'Poppins', sans-serif;
      font-size:1.25rem;
      text-align:center;
      margin-bottom:0.75rem;
    }

    .instructions-card p{
      color:var(--muted);
      line-height:1.55;
      font-weight:600;
      font-size:0.98rem;
      margin-bottom:0.9rem;
      text-align:center;
    }

    .kbd{
      display:inline-flex;
      align-items:center;
      gap:0.4rem;
      padding:0.2rem 0.5rem;
      border-radius:0.5rem;
      border:1px solid rgba(148,163,184,0.22);
      background: rgba(30,41,59,0.45);
      font-weight:800;
      color:var(--text);
      font-size:0.9rem;
    }

    .dot{
      display:inline-block;
      width:0.55rem;
      height:0.55rem;
      border-radius:999px;
      vertical-align:middle;
      margin:0 0.25rem;
      background: var(--ready);
      box-shadow: 0 0 0 6px rgba(16,185,129,0.12);
    }

    .instruction-cta{
      display:flex;
      gap:0.75rem;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:0.35rem;
    }

    button{
      font-family:'Inter', system-ui, sans-serif;
      font-size:0.98rem;
      font-weight:800;
      padding:0.9rem 1.25rem;
      border:none;
      border-radius:0.9rem;
      cursor:pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, opacity 160ms ease;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }

    button:hover{
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.32);
    }

    button:active{ transform: translateY(0); }

    button:disabled{ opacity:0.5; cursor:not-allowed; transform:none; box-shadow: 0 8px 24px rgba(0,0,0,0.16); }

    .btn-primary{
      background: linear-gradient(135deg, var(--primary) 0%, #2563EB 100%);
      color:#fff;
    }
    .btn-secondary{
      background: rgba(30,41,59,0.55);
      color: var(--text);
      border: 1px solid rgba(148,163,184,0.18);
    }
    .btn-danger{
      background: linear-gradient(135deg, var(--error) 0%, #DC2626 100%);
      color:#fff;
    }

    /* Supporting UI: compact stats row */
    .stats{
      width:100%;
      max-width:640px;
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:0.75rem;
      margin-top:0.25rem;
    }

    .stat{
      background: rgba(30,41,59,0.55);
      border: 1px solid rgba(148,163,184,0.12);
      border-radius: 0.95rem;
      padding:0.9rem 1rem;
    }

    .stat .label{
      font-size:0.78rem;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:800;
      margin-bottom:0.4rem;
    }

    .stat .value{
      font-family:'Poppins', sans-serif;
      font-size:1.35rem;
      font-weight:800;
      color: var(--primary);
      line-height:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .unit{
      font-family:'Inter', sans-serif;
      font-size:0.95rem;
      font-weight:800;
      margin-left:0.2rem;
      color: var(--muted);
    }

    /* Minimal controls: only what matters */
    .controls{
      width:100%;
      max-width:640px;
      display:flex;
      justify-content:center;
      gap:0.75rem;
      flex-wrap:wrap;
      margin-top:0.4rem;
    }

    footer{
      padding:1.25rem;
      text-align:center;
      color: rgba(148,163,184,0.75);
      font-size:0.85rem;
    }

    @media (max-width: 720px){
      h1{ font-size:1.95rem; }
      main{ padding:1.35rem 1rem 1.75rem; }
      .status .big{ font-size:2.05rem; }
      .stats{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>

<body>
<header>
  <h1>3D Reaction Timer</h1>
  <p class="subtitle">A clean, focused reflex test with 3D feedback</p>
</header>

<main>
  <div class="game-container">
    <!-- Start is discoverable: click anywhere in here or press Space -->
    <div class="canvas-wrapper" id="canvasWrapper" role="button" tabindex="0"
         aria-label="Game area. Click or press Space to start and react.">
      <canvas id="gameCanvas"></canvas>

      <div class="hud">
        <div class="status idle visible" id="statusBox">
          <div class="big" id="statusBig">Click anywhere or press Space</div>
          <div class="sub" id="statusSub">Start a round, then react when it turns green</div>
        </div>
      </div>

      <div class="instructions" id="instructionsOverlay">
        <div class="instructions-card">
          <h2>Quick instructions</h2>
          <p>
            <span class="kbd">Space</span> or <strong>click anywhere</strong> to start.
            Wait for the shape to turn <span class="dot"></span><strong>green</strong>, then click/press <span class="kbd">Space</span> as fast as you can.
            <br><br>
            Clicking early is a <strong style="color:var(--error);">false start</strong>.
          </p>
          <div class="instruction-cta">
            <button class="btn-primary" id="startFromOverlayBtn" type="button">Start (Space)</button>
            <button class="btn-secondary" id="dismissOverlayBtn" type="button">Got it</button>
          </div>
        </div>
      </div>
    </div>

    <div class="stats" aria-label="Session statistics">
      <div class="stat">
        <div class="label">Last</div>
        <div class="value" id="lastTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Average</div>
        <div class="value" id="avgTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Best</div>
        <div class="value" id="bestTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Attempts</div>
        <div class="value" id="attempts">0</div>
      </div>
    </div>

    <div class="controls" aria-label="Controls">
      <button class="btn-primary" id="startBtn" type="button">Start</button>
      <button class="btn-danger" id="stopBtn" type="button" disabled>Stop</button>
      <button class="btn-secondary" id="resetBtn" type="button">Reset</button>
    </div>
  </div>
</main>

<footer>
  Built with Three.js • Designed for clarity and flow
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  const GameState = {
    IDLE: 'idle',
    WAITING: 'waiting',
    ACTIVE: 'active',
    RESULT: 'result',
    ERROR: 'error',
  };

  // Human-friendly categories
  function gradeReaction(ms) {
    if (ms < 150) return { label: 'Amazing', detail: 'Elite reflexes', key: 'amazing' };
    if (ms < 200) return { label: 'Very Good', detail: 'Fast and consistent', key: 'very-good' };
    if (ms < 250) return { label: 'Good', detail: 'Above average', key: 'good' };
    if (ms < 300) return { label: 'Average', detail: 'Typical range', key: 'average' };
    return { label: 'Below Average', detail: 'Warm up and try again', key: 'below-average' };
  }

  class ReactionTimer {
    constructor() {
      this.state = GameState.IDLE;
      this.startTime = null;
      this.waitTimeout = null;

      // Attempts = rounds started (button or space or click)
      this.roundsStarted = 0;

      // Valid reaction times only
      this.reactionTimes = [];
      this.currentAttempt = null;

      // Instructions: shown once per page load; disappear naturally when play begins
      this.instructionsVisible = true;
      this.overlayEverDismissed = false;

      // Space handling
      this._spaceDown = false;

      this.initDOM();
      this.initThree();
      this.initEvents();
      this.updateStats();
      this.setIdleVisual();
      this.focusGameArea();
      this.animate();
    }

    initDOM() {
      this.canvasWrapper = document.getElementById('canvasWrapper');
      this.canvas = document.getElementById('gameCanvas');

      this.statusBox = document.getElementById('statusBox');
      this.statusBig = document.getElementById('statusBig');
      this.statusSub = document.getElementById('statusSub');

      this.instructionsOverlay = document.getElementById('instructionsOverlay');
      this.startFromOverlayBtn = document.getElementById('startFromOverlayBtn');
      this.dismissOverlayBtn = document.getElementById('dismissOverlayBtn');

      this.startBtn = document.getElementById('startBtn');
      this.stopBtn = document.getElementById('stopBtn');
      this.resetBtn = document.getElementById('resetBtn');

      this.lastTimeEl = document.getElementById('lastTime');
      this.avgTimeEl = document.getElementById('avgTime');
      this.bestTimeEl = document.getElementById('bestTime');
      this.attemptsEl = document.getElementById('attempts');
    }

    initThree() {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x1E293B);

      this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      this.camera.position.z = 5;

      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
      this.updateRendererSize();

      // Lighting
      this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));

      const dir1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dir1.position.set(5, 5, 5);
      this.scene.add(dir1);

      const dir2 = new THREE.DirectionalLight(0x3B82F6, 0.55);
      dir2.position.set(-5, -5, 6);
      this.scene.add(dir2);

      const point = new THREE.PointLight(0x10B981, 0.75, 100);
      point.position.set(0, 0, 8);
      this.scene.add(point);

      // Shape
      const geom = new THREE.IcosahedronGeometry(1.5, 1);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x334155,
        metalness: 0.85,
        roughness: 0.22,
        flatShading: true
      });
      this.shape = new THREE.Mesh(geom, mat);
      this.scene.add(this.shape);

      // Wireframe accent
      const wireGeom = new THREE.IcosahedronGeometry(1.52, 1);
      const wireMat = new THREE.MeshBasicMaterial({
        color: 0x475569,
        wireframe: true,
        transparent: true,
        opacity: 0.25
      });
      this.wire = new THREE.Mesh(wireGeom, wireMat);
      this.scene.add(this.wire);

      window.addEventListener('resize', () => this.updateRendererSize(), { passive: true });
    }

    updateRendererSize() {
      const parent = this.canvas.parentElement;
      const w = parent.clientWidth;
      const h = parent.clientHeight;
      this.camera.aspect = w / h;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(w, h);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    initEvents() {
      // Primary start: click anywhere in game area OR Space
      this.canvasWrapper.addEventListener('click', () => {
        this.handlePress('pointer');
      });

      // Start button (kept for discoverability, but not required)
      this.startBtn.addEventListener('click', () => {
        this.handlePress('startBtn');
      });

      this.stopBtn.addEventListener('click', () => this.stopGame());
      this.resetBtn.addEventListener('click', () => this.resetStats());

      // Overlay actions
      this.dismissOverlayBtn.addEventListener('click', () => this.dismissOverlay());
      this.startFromOverlayBtn.addEventListener('click', () => this.handlePress('overlayStart'));

      // Space always works (prevents "press focused button" behavior)
      window.addEventListener('keydown', (e) => {
        if (e.code !== 'Space') return;
        e.preventDefault();
        if (this._spaceDown) return;
        this._spaceDown = true;

        const active = document.activeElement;
        if (active && ['BUTTON','INPUT','TEXTAREA','SELECT'].includes(active.tagName)) active.blur();
        this.focusGameArea();

        this.handlePress('space');
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        if (e.code !== 'Space') return;
        this._spaceDown = false;
      });
    }

    focusGameArea() {
      // keeps keyboard flow consistent
      this.canvasWrapper.focus();
    }

    dismissOverlay() {
      if (!this.instructionsVisible) return;
      this.instructionsVisible = false;
      this.overlayEverDismissed = true;
      this.instructionsOverlay.classList.add('hidden');
      this.focusGameArea();
    }

    dismissOverlayIfNeeded() {
      // shown only once per load; disappears naturally when the game begins
      if (this.instructionsVisible && !this.overlayEverDismissed) {
        this.dismissOverlay();
      } else if (this.instructionsVisible) {
        // if user kept it visible but starts anyway, hide it
        this.dismissOverlay();
      }
    }

    handlePress(source) {
      // If idle/result/error: start a round
      if (this.state === GameState.IDLE || this.state === GameState.RESULT || this.state === GameState.ERROR) {
        this.dismissOverlayIfNeeded();
        this.startGame();
        return;
      }
      // If waiting: false start
      if (this.state === GameState.WAITING) {
        this.handleFalseStart();
        return;
      }
      // If active: record
      if (this.state === GameState.ACTIVE) {
        this.recordReaction();
        return;
      }
    }

    startGame() {
      if (this.state === GameState.WAITING || this.state === GameState.ACTIVE) return;

      this.clearWaitTimeout();

      // Attempts count starts (any method)
      this.roundsStarted += 1;
      this.updateStats();

      this.state = GameState.WAITING;

      this.startBtn.disabled = true;
      this.stopBtn.disabled = false;

      this.currentAttempt = null;

      this.setWaitingVisual();
      this.setStatus('WAIT…', 'Click/Space when it turns green', 'wait', true);

      const delay = 1000 + Math.random() * 4000;
      this.waitTimeout = setTimeout(() => this.activateStimulus(), delay);
      this.focusGameArea();
    }

    activateStimulus() {
      if (this.state !== GameState.WAITING) return;

      this.state = GameState.ACTIVE;
      this.startTime = performance.now();

      this.setActiveVisual();
      this.setStatus('GO!', 'React now', 'go', true);

      this.shape.userData.fast = true;
      this.wire.userData.fast = true;
    }

    handleFalseStart() {
      if (this.state !== GameState.WAITING) return;

      this.clearWaitTimeout();
      this.state = GameState.ERROR;

      this.setErrorVisual();
      this.setStatus('Too early', 'False start — start again', 'err', false, 1400);

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      setTimeout(() => {
        if (this.state === GameState.ERROR) {
          this.state = GameState.IDLE;
          this.setIdleVisual();
          this.setStatus('Click anywhere or press Space', 'Start a round, then react on green', 'idle', true);
          this.focusGameArea();
        }
      }, 900);
    }

    recordReaction() {
      if (this.state !== GameState.ACTIVE || this.startTime == null) return;

      const ms = Math.max(0, Math.round(performance.now() - this.startTime));
      this.currentAttempt = ms;
      this.reactionTimes.push(ms);

      const g = gradeReaction(ms);

      this.state = GameState.RESULT;

      // Human-friendly result: category + short meaning
      this.setStatus(`${ms} ms`, `${g.label} — ${g.detail}`, 'result', false, 2600);

      this.updateStats();
      this.setIdleVisual();

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;

      setTimeout(() => {
        if (this.state === GameState.RESULT) {
          this.setStatus('Click anywhere or press Space', 'Try again to beat your best', 'idle', true);
        }
      }, 2650);

      this.focusGameArea();
    }

    stopGame() {
      if (this.state !== GameState.WAITING && this.state !== GameState.ACTIVE) return;

      this.clearWaitTimeout();
      this.state = GameState.IDLE;

      this.setIdleVisual();
      this.setStatus('Stopped', 'Click/Space to start again', 'idle', false, 1200);

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;

      setTimeout(() => {
        if (this.state === GameState.IDLE) {
          this.setStatus('Click anywhere or press Space', 'Start a round, then react on green', 'idle', true);
        }
      }, 1250);

      this.focusGameArea();
    }

    resetStats() {
      this.roundsStarted = 0;
      this.reactionTimes = [];
      this.currentAttempt = null;
      this.updateStats();

      this.setStatus('Reset', 'Stats cleared', 'idle', false, 900);

      if (this.state !== GameState.WAITING && this.state !== GameState.ACTIVE) {
        this.state = GameState.IDLE;
        this.setIdleVisual();
        setTimeout(() => {
          if (this.state === GameState.IDLE) {
            this.setStatus('Click anywhere or press Space', 'Start a round, then react on green', 'idle', true);
          }
        }, 950);
      }

      this.focusGameArea();
    }

    clearWaitTimeout() {
      if (this.waitTimeout) {
        clearTimeout(this.waitTimeout);
        this.waitTimeout = null;
      }
    }

    setStatus(big, sub, mode, persist, autoHideMs) {
      this.statusBox.className = `status visible ${mode}`;
      this.statusBig.textContent = big;
      this.statusSub.textContent = sub;

      if (persist) return;

      const ms = typeof autoHideMs === 'number' ? autoHideMs : 1800;
      setTimeout(() => {
        // only hide if still showing same text
        if (this.statusBig.textContent === big && !persist) {
          this.statusBox.classList.remove('visible');
        }
      }, ms);
    }

    setIdleVisual() {
      this.shape.material.color.setHex(0x334155);
      this.shape.material.emissive.setHex(0x000000);
      this.shape.material.emissiveIntensity = 0;

      this.wire.material.color.setHex(0x475569);
      this.wire.material.opacity = 0.25;
    }

    setWaitingVisual() {
      this.shape.material.color.setHex(0xF59E0B);
      this.shape.material.emissive.setHex(0xF59E0B);
      this.shape.material.emissiveIntensity = 0.28;

      this.wire.material.color.setHex(0xF59E0B);
      this.wire.material.opacity = 0.45;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;
    }

    setActiveVisual() {
      this.shape.material.color.setHex(0x10B981);
      this.shape.material.emissive.setHex(0x10B981);
      this.shape.material.emissiveIntensity = 0.82;

      this.wire.material.color.setHex(0x10B981);
      this.wire.material.opacity = 0.82;
    }

    setErrorVisual() {
      this.shape.material.color.setHex(0xEF4444);
      this.shape.material.emissive.setHex(0xEF4444);
      this.shape.material.emissiveIntensity = 0.5;

      this.wire.material.color.setHex(0xEF4444);
      this.wire.material.opacity = 0.6;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;
    }

    updateStats() {
      if (this.currentAttempt != null) {
        this.lastTimeEl.innerHTML = `${this.currentAttempt}<span class="unit">ms</span>`;
      } else {
        this.lastTimeEl.textContent = '—';
      }

      this.attemptsEl.textContent = String(this.roundsStarted);

      if (this.reactionTimes.length === 0) {
        this.avgTimeEl.textContent = '—';
        this.bestTimeEl.textContent = '—';
        return;
      }

      const avg = Math.round(this.reactionTimes.reduce((s, t) => s + t, 0) / this.reactionTimes.length);
      const best = Math.min(...this.reactionTimes);

      this.avgTimeEl.innerHTML = `${avg}<span class="unit">ms</span>`;
      this.bestTimeEl.innerHTML = `${best}<span class="unit">ms</span>`;
    }

    animate() {
      requestAnimationFrame(() => this.animate());

      const fast = !!this.shape.userData.fast;
      const s = fast ? 0.055 : 0.008;

      this.shape.rotation.x += s;
      this.shape.rotation.y += s * 1.18;

      this.wire.rotation.x += s;
      this.wire.rotation.y += s * 1.18;

      this.renderer.render(this.scene, this.camera);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    new ReactionTimer();
  });
</script>
</body>
</html>
