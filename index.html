```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reaction Timer | Portfolio Project</title>

  <!-- Subtle inline SVG favicon -->
  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop stop-color="%233B82F6"/><stop offset="1" stop-color="%2310B981"/></linearGradient></defs><rect width="64" height="64" rx="14" fill="%230F172A"/><circle cx="32" cy="32" r="18" fill="url(%23g)"/><circle cx="32" cy="32" r="7" fill="%230B1224"/></svg>' />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@600;700&display=swap');

    :root{
      --bg:#0F172A;
      --surface:#1E293B;
      --surface-2:#0B1224;
      --border:#334155;
      --text:#F1F5F9;
      --muted:#94A3B8;
      --primary:#3B82F6;
      --go:#10B981;
      --wait:#F59E0B;
      --error:#EF4444;
    }

    *{ margin:0; padding:0; box-sizing:border-box; }

    body{
      font-family:'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      flex-direction:column;
      overflow-x:hidden;
    }

    /* tighter header → play area */
    header{
      padding:1.15rem 1.25rem 0.7rem;
      text-align:center;
      background: linear-gradient(180deg, var(--surface) 0%, rgba(30,41,59,0) 100%);
    }

    h1{
      font-family:'Poppins', sans-serif;
      font-size:2.05rem;
      font-weight:700;
      line-height:1.1;
      margin-bottom:0.22rem;
      background: linear-gradient(135deg, var(--primary) 0%, var(--go) 100%);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }

    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
      font-weight:600;
    }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:0.85rem 1.1rem 1.45rem;
    }

    .game-container{
      width:100%;
      max-width:860px;
      display:flex;
      flex-direction:column;
      gap:0.85rem;
      align-items:center;
    }

    .canvas-wrapper{
      position:relative;
      width:100%;
      max-width:640px;
      aspect-ratio:1;
      background:var(--surface);
      border-radius:1.35rem;
      overflow:hidden;
      border:2px solid var(--border);
      box-shadow: 0 20px 55px rgba(0,0,0,0.35);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      outline:none;
    }

    .canvas-wrapper:hover{ border-color:#475569; }

    .canvas-wrapper:focus-visible{
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(59,130,246,0.25), 0 20px 55px rgba(0,0,0,0.35);
    }

    #gameCanvas{ display:block; width:100%; height:100%; }

    .hud{
      position:absolute;
      inset:0;
      z-index:10;
      pointer-events:none;
    }

    /* Top-right feedback: results / errors / waiting */
    .status{
      position:absolute;
      top:0.85rem;
      right:0.85rem;
      max-width: calc(100% - 1.7rem);
      padding:0.75rem 0.9rem;
      border-radius:0.9rem;
      border:1px solid transparent;
      background: rgba(11,18,36,0.78);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 28px rgba(0,0,0,0.28);
      opacity:0;
      transform: translateY(-4px);
      transition: opacity 180ms ease, transform 180ms ease, border-color 180ms ease;
      font-family:'Poppins', sans-serif;
      line-height:1.15;
    }
    .status.visible{ opacity:1; transform: translateY(0); }

    .status .big{
      font-size:2.15rem;
      font-weight:700;
      letter-spacing:-0.02em;
    }
    .status .sub{
      margin-top:0.32rem;
      font-family:'Inter', sans-serif;
      color:var(--muted);
      font-size:0.92rem;
      font-weight:700;
    }

    .status.idle{ border-color: rgba(148,163,184,0.14); }
    .status.wait{ border-color: rgba(245,158,11,0.5); }
    .status.go{ border-color: rgba(16,185,129,0.55); }
    .status.result{ border-color: rgba(59,130,246,0.55); }
    .status.err{ border-color: rgba(239,68,68,0.55); }

    .status.idle .big{ color: var(--muted); font-size:1.05rem; }
    .status.wait .big{ color: var(--wait); }
    .status.go .big{ color: var(--go); }
    .status.result .big{ color: var(--primary); }
    .status.err .big{ color: var(--error); font-size:1.08rem; }

    /* Instruction INSIDE play area, bottom-center under the shape */
    .in-game-instruction{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      bottom:0.85rem;
      width: calc(100% - 1.7rem);
      max-width: 560px;
      text-align:center;
      padding:0.72rem 0.9rem;
      border-radius:0.95rem;
      border:1px solid rgba(148,163,184,0.16);
      background: rgba(11,18,36,0.72);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 28px rgba(0,0,0,0.22);
      opacity:1;
      transition: opacity 220ms ease, transform 220ms ease;
      color: var(--muted);
      font-weight:900;
      font-size:0.98rem;
      pointer-events:none;
    }

    .in-game-instruction.hidden{
      opacity:0;
      transform: translateX(-50%) translateY(6px);
    }

    /* Stats: compact, supportive */
    .stats{
      width:100%;
      max-width:640px;
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:0.7rem;
    }

    .stat{
      background: rgba(30,41,59,0.55);
      border: 1px solid rgba(148,163,184,0.12);
      border-radius: 0.95rem;
      padding:0.85rem 0.95rem;
    }

    .stat .label{
      font-size:0.76rem;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:900;
      margin-bottom:0.35rem;
    }

    .stat .value{
      font-family:'Poppins', sans-serif;
      font-size:1.32rem;
      font-weight:800;
      color: var(--primary);
      line-height:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .unit{
      font-family:'Inter', sans-serif;
      font-size:0.92rem;
      font-weight:900;
      margin-left:0.2rem;
      color: var(--muted);
    }

    .controls{
      width:100%;
      max-width:640px;
      display:flex;
      justify-content:center;
      gap:0.65rem;
      flex-wrap:wrap;
      margin-top:0.05rem;
    }

    button{
      font-family:'Inter', system-ui, sans-serif;
      font-size:0.98rem;
      font-weight:900;
      padding:0.85rem 1.15rem;
      border:none;
      border-radius:0.9rem;
      cursor:pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, opacity 160ms ease;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }

    button:hover{
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.32);
    }
    button:active{ transform: translateY(0); }
    button:disabled{ opacity:0.5; cursor:not-allowed; transform:none; box-shadow: 0 8px 24px rgba(0,0,0,0.16); }

    .btn-primary{
      background: linear-gradient(135deg, var(--primary) 0%, #2563EB 100%);
      color:#fff;
    }
    .btn-danger{
      background: linear-gradient(135deg, var(--error) 0%, #DC2626 100%);
      color:#fff;
    }
    .btn-secondary{
      background: rgba(30,41,59,0.55);
      color: var(--text);
      border: 1px solid rgba(148,163,184,0.18);
    }

    footer{
      padding:0.95rem 1.25rem 1.05rem;
      text-align:center;
      color: rgba(148,163,184,0.72);
      font-size:0.85rem;
    }

    /* Mobile: tighter spacing, remove space-bar references via JS + media */
    @media (max-width: 720px){
      header{ padding:1rem 1rem 0.6rem; }
      main{ padding:0.7rem 0.9rem 1.2rem; }
      h1{ font-size:1.85rem; }
      .subtitle{ font-size:0.9rem; }

      .canvas-wrapper{
        max-width: 92vw;
        border-radius:1.25rem;
      }

      .status{ top:0.7rem; right:0.7rem; padding:0.68rem 0.82rem; }
      .status .big{ font-size:1.95rem; }
      .status .sub{ font-size:0.88rem; }

      .in-game-instruction{
        bottom:0.72rem;
        font-size:0.95rem;
      }

      .stats{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      button{ width:100%; max-width:220px; }
    }

    /* If the device is touch-first, we’ll never show keyboard hint */
    @media (hover: none) and (pointer: coarse){
      .kbdHint{ display:none !important; }
    }
  </style>
</head>

<body>
<header>
  <h1>Reaction Timer</h1>
  <p class="subtitle">Tap/click to start, react on green</p>
</header>

<main>
  <div class="game-container">
    <div class="canvas-wrapper" id="canvasWrapper" role="button" tabindex="0"
         aria-label="Game area. Tap or click to start and react.">
      <canvas id="gameCanvas"></canvas>

      <div class="hud">
        <div class="status idle visible" id="statusBox" aria-live="polite">
          <div class="big" id="statusBig">Ready</div>
          <div class="sub" id="statusSub">Tap/click to start</div>
        </div>

        <!-- Instruction positioned below the interactive shape (inside play area) -->
        <div class="in-game-instruction" id="inGameHint">
          Click here<span class="kbdHint"> or press space</span> to start
        </div>
      </div>
    </div>

    <div class="stats" aria-label="Session statistics">
      <div class="stat">
        <div class="label">Last</div>
        <div class="value" id="lastTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Average</div>
        <div class="value" id="avgTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Best</div>
        <div class="value" id="bestTime">—</div>
      </div>
      <div class="stat">
        <div class="label">Attempts</div>
        <div class="value" id="attempts">0</div>
      </div>
    </div>

    <div class="controls" aria-label="Controls">
      <button class="btn-primary" id="startBtn" type="button">Start</button>
      <button class="btn-danger" id="stopBtn" type="button" disabled>Stop</button>
      <button class="btn-secondary" id="resetBtn" type="button">Reset</button>
    </div>
  </div>
</main>

<footer>
  Built with Three.js • Clean, responsive interaction design
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  const GameState = {
    IDLE: 'idle',
    WAITING: 'waiting',
    ACTIVE: 'active',
    RESULT: 'result',
    ERROR: 'error',
  };

  function gradeReaction(ms) {
    if (ms < 150) return { label: 'Amazing', detail: 'Elite reflexes' };
    if (ms < 200) return { label: 'Very Good', detail: 'Fast and consistent' };
    if (ms < 250) return { label: 'Good', detail: 'Above average' };
    if (ms < 300) return { label: 'Average', detail: 'Typical range' };
    return { label: 'Below Average', detail: 'Warm up and try again' };
  }

  class ReactionTimer {
    constructor() {
      this.state = GameState.IDLE;
      this.startTime = null;
      this.waitTimeout = null;

      // Attempts = rounds started (any method)
      this.roundsStarted = 0;

      // Valid reactions only
      this.reactionTimes = [];
      this.currentAttempt = null;

      // Space handling (desktop)
      this._spaceDown = false;

      this.initDOM();
      this.initThree();
      this.initEvents();
      this.updateStats();
      this.setIdleVisual();
      this.focusGameArea();
      this.updatePlatformCopy();

      this.animate();
    }

    initDOM() {
      this.canvasWrapper = document.getElementById('canvasWrapper');
      this.canvas = document.getElementById('gameCanvas');

      this.statusBox = document.getElementById('statusBox');
      this.statusBig = document.getElementById('statusBig');
      this.statusSub = document.getElementById('statusSub');

      this.inGameHint = document.getElementById('inGameHint');

      this.startBtn = document.getElementById('startBtn');
      this.stopBtn = document.getElementById('stopBtn');
      this.resetBtn = document.getElementById('resetBtn');

      this.lastTimeEl = document.getElementById('lastTime');
      this.avgTimeEl = document.getElementById('avgTime');
      this.bestTimeEl = document.getElementById('bestTime');
      this.attemptsEl = document.getElementById('attempts');
    }

    isTouchFirst() {
      return window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
    }

    updatePlatformCopy() {
      // Mobile: remove space-bar references
      if (this.isTouchFirst()) {
        this.inGameHint.textContent = 'Tap here to start';
        this.statusSub.textContent = 'Tap to start';
      } else {
        this.inGameHint.innerHTML = 'Click here<span class="kbdHint"> or press space</span> to start';
        this.statusSub.textContent = 'Click or press space to start';
      }
    }

    initThree() {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x1E293B);

      this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      this.camera.position.z = 5;

      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
      this.updateRendererSize();

      this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));

      const dir1 = new THREE.DirectionalLight(0xffffff, 0.8);
      dir1.position.set(5, 5, 5);
      this.scene.add(dir1);

      const dir2 = new THREE.DirectionalLight(0x3B82F6, 0.55);
      dir2.position.set(-5, -5, 6);
      this.scene.add(dir2);

      const point = new THREE.PointLight(0x10B981, 0.75, 100);
      point.position.set(0, 0, 8);
      this.scene.add(point);

      const geom = new THREE.IcosahedronGeometry(1.5, 1);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x334155,
        metalness: 0.85,
        roughness: 0.22,
        flatShading: true
      });
      this.shape = new THREE.Mesh(geom, mat);
      this.scene.add(this.shape);

      const wireGeom = new THREE.IcosahedronGeometry(1.52, 1);
      const wireMat = new THREE.MeshBasicMaterial({
        color: 0x475569,
        wireframe: true,
        transparent: true,
        opacity: 0.25
      });
      this.wire = new THREE.Mesh(wireGeom, wireMat);
      this.scene.add(this.wire);

      window.addEventListener('resize', () => {
        this.updateRendererSize();
        this.updatePlatformCopy();
      }, { passive: true });
    }

    updateRendererSize() {
      const parent = this.canvas.parentElement;
      const w = parent.clientWidth;
      const h = parent.clientHeight;
      this.camera.aspect = w / h;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(w, h);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    initEvents() {
      // Primary interaction: tap/click inside play area
      this.canvasWrapper.addEventListener('click', () => this.handlePress('pointer'));

      // Start button also starts a round
      this.startBtn.addEventListener('click', () => this.handlePress('startBtn'));

      this.stopBtn.addEventListener('click', () => this.stopGame());
      this.resetBtn.addEventListener('click', () => this.resetStats());

      // Desktop keyboard: Space triggers the same action (hidden on mobile copy)
      window.addEventListener('keydown', (e) => {
        if (e.code !== 'Space') return;
        e.preventDefault();
        if (this._spaceDown) return;
        this._spaceDown = true;

        const active = document.activeElement;
        if (active && ['BUTTON','INPUT','TEXTAREA','SELECT'].includes(active.tagName)) active.blur();

        this.focusGameArea();
        this.handlePress('space');
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        if (e.code !== 'Space') return;
        this._spaceDown = false;
      });
    }

    focusGameArea() {
      this.canvasWrapper.focus();
    }

    handlePress() {
      if (this.state === GameState.IDLE || this.state === GameState.RESULT || this.state === GameState.ERROR) {
        this.startGame();
        return;
      }
      if (this.state === GameState.WAITING) {
        this.handleFalseStart();
        return;
      }
      if (this.state === GameState.ACTIVE) {
        this.recordReaction();
        return;
      }
    }

    startGame() {
      if (this.state === GameState.WAITING || this.state === GameState.ACTIVE) return;

      this.clearWaitTimeout();

      // Attempts increment for every round start
      this.roundsStarted += 1;
      this.updateStats();

      this.state = GameState.WAITING;

      this.startBtn.disabled = true;
      this.stopBtn.disabled = false;

      this.currentAttempt = null;

      // Reduce clutter during active flow
      this.inGameHint.classList.add('hidden');

      this.setWaitingVisual();
      this.setStatus('WAIT…', 'React when it turns green', 'wait', true);

      const delay = 1000 + Math.random() * 4000;
      this.waitTimeout = setTimeout(() => this.activateStimulus(), delay);

      this.focusGameArea();
    }

    activateStimulus() {
      if (this.state !== GameState.WAITING) return;

      this.state = GameState.ACTIVE;
      this.startTime = performance.now();

      this.setActiveVisual();
      this.setStatus('GO!', 'Tap/click now', 'go', true);

      this.shape.userData.fast = true;
      this.wire.userData.fast = true;
    }

    handleFalseStart() {
      if (this.state !== GameState.WAITING) return;

      this.clearWaitTimeout();
      this.state = GameState.ERROR;

      this.setErrorVisual();
      this.setStatus('Too early', 'False start — try again', 'err', false, 1400);

      // Return hint after feedback settles
      setTimeout(() => this.inGameHint.classList.remove('hidden'), 700);

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      setTimeout(() => {
        if (this.state === GameState.ERROR) {
          this.state = GameState.IDLE;
          this.setIdleVisual();
          this.setStatus('Ready', this.isTouchFirst() ? 'Tap to start' : 'Click or press space to start', 'idle', true);
          this.focusGameArea();
        }
      }, 900);
    }

    recordReaction() {
      if (this.state !== GameState.ACTIVE || this.startTime == null) return;

      const ms = Math.max(0, Math.round(performance.now() - this.startTime));
      this.currentAttempt = ms;
      this.reactionTimes.push(ms);

      const g = gradeReaction(ms);

      this.state = GameState.RESULT;

      // Human-friendly category + meaning
      this.setStatus(`${ms} ms`, `${g.label} — ${g.detail}`, 'result', false, 2600);

      this.updateStats();
      this.setIdleVisual();

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;

      // Bring hint back once result fades
      setTimeout(() => {
        if (this.state === GameState.RESULT) {
          this.inGameHint.classList.remove('hidden');
          this.setStatus('Ready', this.isTouchFirst() ? 'Tap to start' : 'Click or press space to start', 'idle', true);
        }
      }, 2650);

      this.focusGameArea();
    }

    stopGame() {
      if (this.state !== GameState.WAITING && this.state !== GameState.ACTIVE) return;

      this.clearWaitTimeout();
      this.state = GameState.IDLE;

      this.setIdleVisual();
      this.setStatus('Stopped', this.isTouchFirst() ? 'Tap to start' : 'Click or press space to start', 'idle', false, 1100);

      this.startBtn.disabled = false;
      this.stopBtn.disabled = true;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;

      this.inGameHint.classList.remove('hidden');

      setTimeout(() => {
        if (this.state === GameState.IDLE) {
          this.setStatus('Ready', this.isTouchFirst() ? 'Tap to start' : 'Click or press space to start', 'idle', true);
        }
      }, 1150);

      this.focusGameArea();
    }

    resetStats() {
      this.roundsStarted = 0;
      this.reactionTimes = [];
      this.currentAttempt = null;
      this.updateStats();

      this.setStatus('Reset', 'Stats cleared', 'idle', false, 900);

      if (this.state !== GameState.WAITING && this.state !== GameState.ACTIVE) {
        this.state = GameState.IDLE;
        this.setIdleVisual();
        setTimeout(() => {
          if (this.state === GameState.IDLE) {
            this.setStatus('Ready', this.isTouchFirst() ? 'Tap to start' : 'Click or press space to start', 'idle', true);
          }
        }, 950);
      }

      this.inGameHint.classList.remove('hidden');
      this.focusGameArea();
    }

    clearWaitTimeout() {
      if (this.waitTimeout) {
        clearTimeout(this.waitTimeout);
        this.waitTimeout = null;
      }
    }

    setStatus(big, sub, mode, persist, autoHideMs) {
      this.statusBox.className = `status visible ${mode}`;
      this.statusBig.textContent = big;
      this.statusSub.textContent = sub;

      if (persist) return;

      const ms = typeof autoHideMs === 'number' ? autoHideMs : 1800;
      setTimeout(() => {
        if (this.statusBig.textContent === big && !persist) {
          this.statusBox.classList.remove('visible');
        }
      }, ms);
    }

    setIdleVisual() {
      this.shape.material.color.setHex(0x334155);
      this.shape.material.emissive.setHex(0x000000);
      this.shape.material.emissiveIntensity = 0;

      this.wire.material.color.setHex(0x475569);
      this.wire.material.opacity = 0.25;
    }

    setWaitingVisual() {
      this.shape.material.color.setHex(0xF59E0B);
      this.shape.material.emissive.setHex(0xF59E0B);
      this.shape.material.emissiveIntensity = 0.28;

      this.wire.material.color.setHex(0xF59E0B);
      this.wire.material.opacity = 0.45;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;
    }

    setActiveVisual() {
      this.shape.material.color.setHex(0x10B981);
      this.shape.material.emissive.setHex(0x10B981);
      this.shape.material.emissiveIntensity = 0.82;

      this.wire.material.color.setHex(0x10B981);
      this.wire.material.opacity = 0.82;
    }

    setErrorVisual() {
      this.shape.material.color.setHex(0xEF4444);
      this.shape.material.emissive.setHex(0xEF4444);
      this.shape.material.emissiveIntensity = 0.5;

      this.wire.material.color.setHex(0xEF4444);
      this.wire.material.opacity = 0.6;

      this.shape.userData.fast = false;
      this.wire.userData.fast = false;
    }

    updateStats() {
      if (this.currentAttempt != null) {
        this.lastTimeEl.innerHTML = `${this.currentAttempt}<span class="unit">ms</span>`;
      } else {
        this.lastTimeEl.textContent = '—';
      }

      this.attemptsEl.textContent = String(this.roundsStarted);

      if (this.reactionTimes.length === 0) {
        this.avgTimeEl.textContent = '—';
        this.bestTimeEl.textContent = '—';
        return;
      }

      const avg = Math.round(this.reactionTimes.reduce((s, t) => s + t, 0) / this.reactionTimes.length);
      const best = Math.min(...this.reactionTimes);

      this.avgTimeEl.innerHTML = `${avg}<span class="unit">ms</span>`;
      this.bestTimeEl.innerHTML = `${best}<span class="unit">ms</span>`;
    }

    animate() {
      requestAnimationFrame(() => this.animate());

      const fast = !!this.shape.userData.fast;
      const s = fast ? 0.055 : 0.008;

      this.shape.rotation.x += s;
      this.shape.rotation.y += s * 1.18;

      this.wire.rotation.x += s;
      this.wire.rotation.y += s * 1.18;

      this.renderer.render(this.scene, this.camera);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    new ReactionTimer();
  });
</script>
</body>
</html>
```
